Определение:
Сортировка пузырьком — это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке, пока массив не будет полностью отсортирован.

ОБЪЯСНЕНИЕ РАБОТЫ КОДА
1. ФУНКЦИЯ bubble_sort_detailed(arr)
python
def bubble_sort_detailed(arr):
    n = len(arr)
    print(f"Начальный массив: {arr}")
    print(f"Длина массива: {n}")
    print("-" * 60)
Что происходит:
Получаем длину массива n
Выводим начальное состояние массива и его длину
Рисуем разделительную лину для наглядности

2. ВНЕШНИЙ ЦИКЛ - ПРОХОДЫ ПО МАССИВУ
python
for i in range(n):
    print(f"\n ИТЕРАЦИЯ {i + 1}:")
    print(f"   Будем просматривать элементы с 0 до {n - i - 1}")
    
    swapped = False
    comparisons = 0
    swaps = 0
Что происходит:
Внешний цикл выполняется n раз (по количеству элементов)
После каждого прохода самый большой элемент "всплывает" в конец
swapped - флаг для оптимизации (если обменов не было, массив отсортирован)

comparisons, swaps - счетчики для статистики

3. ВНУТРЕННИЙ ЦИКЛ - СРАВНЕНИЕ СОСЕДНИХ ЭЛЕМЕНТОВ
python
for j in range(0, n - i - 1):
    comparisons += 1
    print(f"   Сравниваем arr[{j}]={arr[j]} и arr[{j + 1}]={arr[j + 1]}", end="")
    
    if arr[j] > arr[j + 1]:
        arr[j], arr[j + 1] = arr[j + 1], arr[j]
        swapped = True
        swaps += 1
        print(f" → ОБМЕН! Теперь: {arr}")
    else:
        print(f" → порядок верный")
Что происходит:
Внутренний цикл проходит по неотсортированной части массива
Сравнивает соседние элементы arr[j] и arr[j+1]
Если порядок неправильный - меняет их местами
Увеличивает счетчики сравнений и обменов
Выводит подробную информацию о каждом сравнении

4. ПРОВЕРКА НА ДОСРОЧНОЕ ЗАВЕРШЕНИЕ
python
if not swapped:
    print(f"    Не было обменов! Массив отсортирован после {i + 1} итераций")
    break
else:
    print(f"   Последние {i + 1} элемент(ов) на своих местах")
Оптимизация: Если за весь проход не было ни одного обмена, массив уже отсортирован и можно завершить работу досрочно.

ПРИМЕР ВЫПОЛНЕНИЯ ДЛЯ МАССИВА [64, 34, 25, 12, 22]
ИТЕРАЦИЯ 1:
text
Сравниваем arr[0]=64 и arr[1]=34 → ОБМЕН! Теперь: [34, 64, 25, 12, 22]
Сравниваем arr[1]=64 и arr[2]=25 → ОБМЕН! Теперь: [34, 25, 64, 12, 22]
Сравниваем arr[2]=64 и arr[3]=12 → ОБМЕН! Теперь: [34, 25, 12, 64, 22]
Сравниваем arr[3]=64 и arr[4]=22 → ОБМЕН! Теперь: [34, 25, 12, 22, 64]
Результат: Самый большой элемент 64 "всплыл" в конец

ИТЕРАЦИЯ 2:
text
Сравниваем arr[0]=34 и arr[1]=25 → ОБМЕН! Теперь: [25, 34, 12, 22, 64]
Сравниваем arr[1]=34 и arr[2]=12 → ОБМЕН! Теперь: [25, 12, 34, 22, 64]
Сравниваем arr[2]=34 и arr[3]=22 → ОБМЕН! Теперь: [25, 12, 22, 34, 64]
Результат: Элементы 34 и 64 на своих местах

ИТЕРАЦИЯ 3:
text
Сравниваем arr[0]=25 и arr[1]=12 → ОБМЕН! Теперь: [12, 25, 22, 34, 64]
Сравниваем arr[1]=25 и arr[2]=22 → ОБМЕН! Теперь: [12, 22, 25, 34, 64]
Результат: Элементы 25, 34, 64 на своих местах

ИТЕРАЦИЯ 4:
text
Сравниваем arr[0]=12 и arr[1]=22 → порядок верный
Результат: Массив полностью отсортирован!

ВРЕМЕННАЯ СЛОЖНОСТЬ СОРТИРОВКИ ПУЗЫРЬКОМ

O(n²)
Когда возникает: Массив отсортирован в обратном порядке [5, 4, 3, 2, 1]
Количество операций:
Проход 1: (n-1) сравнений + (n-1) обменов
Проход 2: (n-2) сравнений + (n-2) обменов
Проход 3: (n-3) сравнений + (n-3) обменов
...
Проход n-1: 1 сравнение + 1 обмен

Общее количество операций:
Сравнения: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
Обмены: тоже n(n-1)/2 ≈ n²/2
Итого: O(n²) + O(n²) = O(n²)
