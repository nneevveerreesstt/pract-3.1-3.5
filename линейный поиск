Определение:
Последовательный поиск — это простейший алгоритм поиска, который проверяет каждый элемент структуры данных в заданном порядке до тех пор, пока не будет найден искомый элемент или не будут проверены все элементы.
ОБЩИЙ ПРИНЦИП РАБОТЫ АЛГОРИТМА ПОСЛЕДОВАТЕЛЬНОГО ПОИСКА
ОСНОВНАЯ ИДЕЯ
Последовательный поиск - это простейший алгоритм поиска, который проверяет каждый элемент массива по очереди до тех пор, пока не найдет искомый элемент или не проверит все элементы.
КЛЮЧЕВОЙ ПРИНЦИП
python
for i in range(len(arr)):
    if arr[i] == target:
        return i  # Нашли - возвращаем индекс
return -1  # Не нашли - возвращаем -1
"Последовательно проверяй каждый элемент, пока не найдешь нужный"

ПРОЦЕСС РАБОТЫ ПОШАГОВО
ДЛЯ МАССИВА [64, 34, 25, 12, 22] И target = 25:
text
Шаг 1: Проверяем arr[0] = 64 ≠ 25 → продолжаем
Шаг 2: Проверяем arr[1] = 34 ≠ 25 → продолжаем  
Шаг 3: Проверяем arr[2] = 25 = 25 → НАЙДЕНО!
Возвращаем индекс 2
ЕСЛИ ЭЛЕМЕНТ ОТСУТСТВУЕТ (target = 99):
text
Шаг 1: 64 ≠ 99 → продолжаем
Шаг 2: 34 ≠ 99 → продолжаем
Шаг 3: 25 ≠ 99 → продолжаем
Шаг 4: 12 ≠ 99 → продолжаем
Шаг 5: 22 ≠ 99 → массив закончился
Возвращаем -1
РАЗЛИЧНЫЕ ВАРИАНТЫ РЕАЛИЗАЦИИ
1. БАЗОВЫЙ ПОИСК - находит первое вхождение
python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
2. ПОИСК ВСЕХ ВХОЖДЕНИЙ - находит все позиции
python
def linear_search_all_occurrences(arr, target):
    indices = []
    for i in range(len(arr)):
        if arr[i] == target:
            indices.append(i)
    return indices
3. ПОИСК СО СТРАЖЕМ - оптимизация без проверки границ
python
def linear_search_with_sentinel(arr, target):
    last = arr[-1]  # Сохраняем последний элемент
    arr[-1] = target  # Ставим "страж"
    
    i = 0
    while arr[i] != target:  # Не проверяем границы!
        i += 1
    
    arr[-1] = last  # Восстанавливаем
    
    if i < len(arr) - 1 or arr[-1] == target:
        return i
    return -1
4. ПОИСК ПО УСЛОВИЮ - универсальный поиск
python
def linear_search_condition(arr, condition_func):
    for i in range(len(arr)):
        if condition_func(arr[i]):  # Любое условие
            return i, arr[i]
    return -1, None

Временная сложность алгоритма:
- **Худший случай:** O(n)
- **Лучший случай:** O(1)  
- **Средний случай:** O(n)

## ПОЧЕМУ ТАК?

### **ХУДШИЙ СЛУЧАЙ: O(n)**
- Элемент в **конце** массива или **отсутствует**
- Нужно проверить **все n элементов**

### **ЛУЧШИЙ СЛУЧАЙ: O(1)**
- Элемент в **начале** массива
- Нужно проверить **только 1 элемент**

### **СРЕДНИЙ СЛУЧАЙ: O(n)**
- Элемент в **середине** массива
- В среднем нужно проверить **n/2 элементов**


**Количество сравнений = позиция элемента (если найден) или n (если не найден)**

ВЫВОД
**Линейный поиск работает за O(n), потому что в худшем случае нужно проверить все элементы массива!**
