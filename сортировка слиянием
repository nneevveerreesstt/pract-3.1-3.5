Определение:
Сортировка слиянием — это алгоритм сортировки, основанный на принципе "разделяй и властвуй", который рекурсивно разделяет массив на меньшие части до тех пор, пока каждая часть не будет содержать один элемент, а затем объединяет эти части в отсортированном порядке.
ОСНОВНАЯ ИДЕЯ
Сортировка слиянием работает по принципу "разделяй и властвуй" - она рекурсивно разделяет массив на мелкие части, сортирует их, а затем объединяет обратно в отсортированном порядке.

ТРИ ОСНОВНЫХ ЭТАПА
1. РАЗДЕЛЕНИЕ (DIVIDE)
cpp
int mid = left + (right - left) / 2;
mergeSort(arr, left, mid);      // Левая половина
mergeSort(arr, mid + 1, right); // Правая половина
Массив делится на две примерно равные части

Процесс повторяется рекурсивно до тех пор, пока не останутся подмассивы из одного элемента

Один элемент считается уже отсортированным (базовый случай)

2. СЛИЯНИЕ (MERGE)
cpp
void merge(vector<int>& arr, int left, int mid, int right) {
    // Создаем временные массивы
    vector<int> leftArr(n1);
    vector<int> rightArr(n2);
    
    // Копируем данные
    for (int i = 0; i < n1; i++) {
        leftArr[i] = arr[left + i];
    }
    // ... аналогично для правой части
}
Создаются два временных массива для левой и правой половин

Данные копируются из основного массива во временные

3. ОБЪЕДИНЕНИЕ (COMBINE)
cpp
while (i < n1 && j < n2) {
    if (leftArr[i] <= rightArr[j]) {
        arr[k] = leftArr[i];
        i++;
    } else {
        arr[k] = rightArr[j];
        j++;
    }
    k++;
}
Сравниваются элементы из двух временных массивов

Меньший элемент помещается в основной массив

Процесс продолжается пока один из массивов не закончится

ПРОЦЕСС СЛИЯНИЯ ПОДРОБНО
ШАГ 1: ПОДГОТОВКА ДАННЫХ
cpp
int n1 = mid - left + 1;    // Размер левой части
int n2 = right - mid;       // Размер правой части
Вычисляются размеры двух половин

Создаются временные массивы точно нужного размера

ШАГ 2: КОПИРОВАНИЕ
cpp
for (int i = 0; i < n1; i++) {
    leftArr[i] = arr[left + i];
}
Данные из левой части основного массива копируются в leftArr

Данные из правой части копируются в rightArr

ШАГ 3: СРАВНЕНИЕ И ВСТАВКА
cpp
while (i < n1 && j < n2) {
    if (leftArr[i] <= rightArr[j]) {
        arr[k] = leftArr[i];
        i++;
    } else {
        arr[k] = rightArr[j];
        j++;
    }
    k++;
}
Указатель i - идет по левому массиву

Указатель j - идет по правому массиву

Указатель k - указывает куда вставлять в основном массиве

На каждом шаге выбирается меньший элемент из двух массивов

ШАГ 4: ДОБАВЛЕНИЕ ОСТАВШИХСЯ ЭЛЕМЕНТОВ
cpp
while (i < n1) {
    arr[k] = leftArr[i];
    i++;
    k++;
}
Если в одном массиве остались элементы, а в другом закончились

Все оставшиеся элементы просто копируются в конец

Временная сложность алгоритма:
Сортировка слиянием имеет временную сложность O(n log n), потому что:
Массив делится на log₂n уровней
На каждом уровне выполняется O(n) операций
Умножение этих факторов дает O(n log n)

Это делает её эффективной для больших массивов, хотя она и требует дополнительной памяти O(n).
